/**
 * generated by Xtext
 */
package dk.itu.smdp.survey.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import dk.itu.smdp.survey.validation.AbstractDslValidator;
import java.util.HashMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import survey.Answer;
import survey.AnswerTemplate;
import survey.Group;
import survey.Item;
import survey.Multiple;
import survey.Option;
import survey.Question;
import survey.Scale;
import survey.Single;
import survey.Survey;
import survey.SurveyPackage.Literals;
import survey.Table;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class DslValidator extends AbstractDslValidator {
  public final static String DUPLICATE_NAME = "duplicateName";
  
  public final static String INVALID_VALUE = "invalidValue";
  
  public final static String INVALID_DATE = "invalidDate";
  
  /**
   * Check that the groups have unique titles
   */
  @Check
  public void checkThatGroupTitlesAreUnique(final Survey survey) {
    HashMap<String,Group> _hashMap = new HashMap<String, Group>();
    HashMap<String,Group> groupMap = _hashMap;
    EList<Item> _items = survey.getItems();
    Iterable<Group> _filter = Iterables.<Group>filter(_items, Group.class);
    for (final Group group : _filter) {
      String _title = group.getTitle();
      boolean _isEmpty = _title.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        String _title_1 = group.getTitle();
        boolean _containsKey = groupMap.containsKey(_title_1);
        if (_containsKey) {
          this.error(
            "Groups must have unique titles", group, 
            Literals.META__TITLE, 
            DslValidator.DUPLICATE_NAME);
        } else {
          String _title_2 = group.getTitle();
          groupMap.put(_title_2, group);
        }
      }
    }
  }
  
  /**
   * Check that questions, not in a group, have a unique ID
   */
  @Check
  public void checkThatQuestionNamesAreUnique(final Survey survey) {
    HashMap<String,Question> _hashMap = new HashMap<String, Question>();
    HashMap<String,Question> questionMap = _hashMap;
    EList<Item> _items = survey.getItems();
    Iterable<Question> _filter = Iterables.<Question>filter(_items, Question.class);
    for (final Question question : _filter) {
      String _name = question.getName();
      boolean _isEmpty = _name.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        String _name_1 = question.getName();
        boolean _containsKey = questionMap.containsKey(_name_1);
        if (_containsKey) {
          this.error(
            "Questions must have unique IDs", question, 
            Literals.META__NAME, 
            DslValidator.DUPLICATE_NAME);
        } else {
          String _name_2 = question.getName();
          questionMap.put(_name_2, question);
        }
      }
    }
  }
  
  /**
   * Check that answers in questions outside of a group have unique IDs
   */
  @Check
  public void checkThatAnswerNamesAreUnique(final Survey survey) {
    EList<Item> _items = survey.getItems();
    Iterable<Question> _filter = Iterables.<Question>filter(_items, Question.class);
    for (final Question question : _filter) {
      {
        HashMap<String,Answer> _hashMap = new HashMap<String, Answer>();
        HashMap<String,Answer> answerMap = _hashMap;
        if ((question instanceof Single)) {
          Single s = ((Single) question);
          EList<Option> _options = s.getOptions();
          Iterable<Answer> _filter_1 = Iterables.<Answer>filter(_options, Answer.class);
          for (final Answer answer : _filter_1) {
            String _name = answer.getName();
            boolean _isEmpty = _name.isEmpty();
            boolean _not = (!_isEmpty);
            if (_not) {
              String _name_1 = answer.getName();
              boolean _containsKey = answerMap.containsKey(_name_1);
              if (_containsKey) {
                this.error(
                  "Answers within a Single must have unique IDs", answer, 
                  Literals.ANSWER__NAME, 
                  DslValidator.DUPLICATE_NAME);
              } else {
                String _name_2 = answer.getName();
                answerMap.put(_name_2, answer);
              }
            }
          }
        } else {
          if ((question instanceof Multiple)) {
            Multiple m = ((Multiple) question);
            EList<Option> _options_1 = m.getOptions();
            Iterable<Answer> _filter_2 = Iterables.<Answer>filter(_options_1, Answer.class);
            for (final Answer answer_1 : _filter_2) {
              String _name_3 = answer_1.getName();
              boolean _isEmpty_1 = _name_3.isEmpty();
              boolean _not_1 = (!_isEmpty_1);
              if (_not_1) {
                String _name_4 = answer_1.getName();
                boolean _containsKey_1 = answerMap.containsKey(_name_4);
                if (_containsKey_1) {
                  this.error(
                    "Answers within a Multiple must have unique IDs", answer_1, 
                    Literals.ANSWER__NAME, 
                    DslValidator.DUPLICATE_NAME);
                } else {
                  String _name_5 = answer_1.getName();
                  answerMap.put(_name_5, answer_1);
                }
              }
            }
          }
        }
        if ((question instanceof Table)) {
          Table t = ((Table) question);
          EList<Option> _options_2 = t.getOptions();
          Iterable<Answer> _filter_3 = Iterables.<Answer>filter(_options_2, Answer.class);
          for (final Answer answer_2 : _filter_3) {
            String _name_6 = answer_2.getName();
            boolean _isEmpty_2 = _name_6.isEmpty();
            boolean _not_2 = (!_isEmpty_2);
            if (_not_2) {
              String _name_7 = answer_2.getName();
              boolean _containsKey_2 = answerMap.containsKey(_name_7);
              if (_containsKey_2) {
                this.error(
                  "Answers within a Table must have unique IDs", answer_2, 
                  Literals.ANSWER__NAME, 
                  DslValidator.DUPLICATE_NAME);
              } else {
                String _name_8 = answer_2.getName();
                answerMap.put(_name_8, answer_2);
              }
            }
          }
        }
      }
    }
  }
  
  /**
   * Check that the questions in each group have unique IDs
   */
  @Check
  public void checkThatQuestionNamesInGroupsAreUnique(final Survey survey) {
    HashMap<String,Question> _hashMap = new HashMap<String, Question>();
    HashMap<String,Question> questionMap = _hashMap;
    EList<Item> _items = survey.getItems();
    Iterable<Group> _filter = Iterables.<Group>filter(_items, Group.class);
    for (final Group group : _filter) {
      EList<Question> _questions = group.getQuestions();
      for (final Question question : _questions) {
        String _name = question.getName();
        boolean _isEmpty = _name.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          String _name_1 = question.getName();
          boolean _containsKey = questionMap.containsKey(_name_1);
          if (_containsKey) {
            this.error(
              "Questions within a group must have unique IDs", question, 
              Literals.META__NAME, 
              DslValidator.DUPLICATE_NAME);
          } else {
            String _name_2 = question.getName();
            questionMap.put(_name_2, question);
          }
        }
      }
    }
  }
  
  /**
   * Check that the answers in each question (of type Single, Multiple or Table) in each group have unique IDs
   */
  @Check
  public void checkThatAnswerNamesInGroupsAreUnique(final Survey survey) {
    EList<Item> _items = survey.getItems();
    Iterable<Group> _filter = Iterables.<Group>filter(_items, Group.class);
    for (final Group group : _filter) {
      EList<Question> _questions = group.getQuestions();
      for (final Question question : _questions) {
        {
          HashMap<String,Answer> _hashMap = new HashMap<String, Answer>();
          HashMap<String,Answer> answerMap = _hashMap;
          if ((question instanceof Single)) {
            Single s = ((Single) question);
            EList<Option> _options = s.getOptions();
            Iterable<Answer> _filter_1 = Iterables.<Answer>filter(_options, Answer.class);
            for (final Answer answer : _filter_1) {
              String _name = answer.getName();
              boolean _isEmpty = _name.isEmpty();
              boolean _not = (!_isEmpty);
              if (_not) {
                String _name_1 = answer.getName();
                boolean _containsKey = answerMap.containsKey(_name_1);
                if (_containsKey) {
                  this.error(
                    "Answers within a Single must have unique IDs", answer, 
                    Literals.ANSWER__NAME, 
                    DslValidator.DUPLICATE_NAME);
                } else {
                  String _name_2 = answer.getName();
                  answerMap.put(_name_2, answer);
                }
              }
            }
          }
          if ((question instanceof Multiple)) {
            Multiple m = ((Multiple) question);
            EList<Option> _options_1 = m.getOptions();
            Iterable<Answer> _filter_2 = Iterables.<Answer>filter(_options_1, Answer.class);
            for (final Answer answer_1 : _filter_2) {
              String _name_3 = answer_1.getName();
              boolean _isEmpty_1 = _name_3.isEmpty();
              boolean _not_1 = (!_isEmpty_1);
              if (_not_1) {
                String _name_4 = answer_1.getName();
                boolean _containsKey_1 = answerMap.containsKey(_name_4);
                if (_containsKey_1) {
                  this.error(
                    "Answers within a Multiple must have unique IDs", answer_1, 
                    Literals.ANSWER__NAME, 
                    DslValidator.DUPLICATE_NAME);
                } else {
                  String _name_5 = answer_1.getName();
                  answerMap.put(_name_5, answer_1);
                }
              }
            }
          }
          if ((question instanceof Table)) {
            Table t = ((Table) question);
            EList<Option> _options_2 = t.getOptions();
            Iterable<Answer> _filter_3 = Iterables.<Answer>filter(_options_2, Answer.class);
            for (final Answer answer_2 : _filter_3) {
              String _name_6 = answer_2.getName();
              boolean _isEmpty_2 = _name_6.isEmpty();
              boolean _not_2 = (!_isEmpty_2);
              if (_not_2) {
                String _name_7 = answer_2.getName();
                boolean _containsKey_2 = answerMap.containsKey(_name_7);
                if (_containsKey_2) {
                  this.error(
                    "Answers within a Table must have unique IDs", answer_2, 
                    Literals.ANSWER__NAME, 
                    DslValidator.DUPLICATE_NAME);
                } else {
                  String _name_8 = answer_2.getName();
                  answerMap.put(_name_8, answer_2);
                }
              }
            }
          }
        }
      }
    }
  }
  
  /**
   * Check that the AnswerTemplates have unique IDs
   */
  @Check
  public void checkThatAnswerTemplateNamesAreUnique(final Survey survey) {
    HashMap<String,AnswerTemplate> _hashMap = new HashMap<String, AnswerTemplate>();
    HashMap<String,AnswerTemplate> answerTemplateMap = _hashMap;
    EList<AnswerTemplate> _templates = survey.getTemplates();
    for (final AnswerTemplate answerTemplate : _templates) {
      String _name = answerTemplate.getName();
      boolean _isEmpty = _name.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        String _name_1 = answerTemplate.getName();
        boolean _containsKey = answerTemplateMap.containsKey(_name_1);
        if (_containsKey) {
          this.error(
            "AnswerTemplates must have unique IDs", answerTemplate, 
            Literals.ANSWER_TEMPLATE__NAME, 
            DslValidator.DUPLICATE_NAME);
        } else {
          String _name_2 = answerTemplate.getName();
          answerTemplateMap.put(_name_2, answerTemplate);
        }
      }
    }
  }
  
  /**
   * Check that the ID of answers in an AnswerTemplate have unique IDs
   */
  @Check
  public void checkThatNamesOfAnswersInAnswerTemplatesAreUnique(final Survey survey) {
    HashMap<String,Answer> _hashMap = new HashMap<String, Answer>();
    HashMap<String,Answer> answerMap = _hashMap;
    EList<AnswerTemplate> _templates = survey.getTemplates();
    for (final AnswerTemplate answerTemplate : _templates) {
      EList<Answer> _answers = answerTemplate.getAnswers();
      for (final Answer answer : _answers) {
        String _name = answer.getName();
        boolean _isEmpty = _name.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          String _name_1 = answer.getName();
          boolean _containsKey = answerMap.containsKey(_name_1);
          if (_containsKey) {
            this.error(
              "Answers within AnswerTemplates must have unique IDs", answer, 
              Literals.ANSWER__NAME, 
              DslValidator.DUPLICATE_NAME);
          } else {
            String _name_2 = answer.getName();
            answerMap.put(_name_2, answer);
          }
        }
      }
    }
  }
  
  /**
   * Check that the max value in a scale question is larger than the min value
   */
  @Check
  public void checkThatLowerIsLargerThanUpperScale(final Survey survey) {
    EList<Item> _items = survey.getItems();
    Iterable<Question> _filter = Iterables.<Question>filter(_items, Question.class);
    for (final Question question : _filter) {
      if ((question instanceof Scale)) {
        Scale scale = ((Scale) question);
        int _min = scale.getMin();
        int _max = scale.getMax();
        boolean _greaterEqualsThan = (_min >= _max);
        if (_greaterEqualsThan) {
          final String minLessThanUpperString = "Scale max value must be larger than min value";
          this.error(minLessThanUpperString, scale, 
            Literals.SCALE__MIN, 
            DslValidator.INVALID_VALUE);
          this.error(minLessThanUpperString, scale, 
            Literals.SCALE__MAX, 
            DslValidator.INVALID_VALUE);
        }
        final String largeScaleString = "Large scales may not render properly nor be very user friendly";
        int _max_1 = scale.getMax();
        int _min_1 = scale.getMin();
        int _minus = (_max_1 - _min_1);
        boolean _greaterThan = (_minus > 20);
        if (_greaterThan) {
          this.warning(largeScaleString, scale, 
            Literals.SCALE__MIN);
          this.warning(largeScaleString, scale, 
            Literals.SCALE__MAX);
        }
        final String bothLabelsString = "You must specify both labels or none of them";
        String _minLabel = scale.getMinLabel();
        boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_minLabel);
        String _maxLabel = scale.getMaxLabel();
        boolean _isNullOrEmpty_1 = StringExtensions.isNullOrEmpty(_maxLabel);
        boolean _notEquals = (_isNullOrEmpty != _isNullOrEmpty_1);
        if (_notEquals) {
          String _minLabel_1 = scale.getMinLabel();
          String _plus = ("Lower \"" + _minLabel_1);
          String _plus_1 = (_plus + "\"");
          InputOutput.<String>println(_plus_1);
          String _maxLabel_1 = scale.getMaxLabel();
          String _plus_2 = ("Upper \"" + _maxLabel_1);
          String _plus_3 = (_plus_2 + "\"");
          InputOutput.<String>println(_plus_3);
          String _minLabel_2 = scale.getMinLabel();
          boolean _isNullOrEmpty_2 = StringExtensions.isNullOrEmpty(_minLabel_2);
          boolean _not = (!_isNullOrEmpty_2);
          if (_not) {
            this.error(bothLabelsString, scale, 
              Literals.SCALE__MIN_LABEL, 
              DslValidator.INVALID_VALUE);
          } else {
            this.error(bothLabelsString, scale, 
              Literals.SCALE__MAX_LABEL, 
              DslValidator.INVALID_VALUE);
          }
        }
      }
    }
  }
  
  /**
   * Check that the max value in a number question is larger than the min value
   */
  @Check
  public void checkThatLowerIsLargerThanUpperNumber(final Survey survey) {
    EList<Item> _items = survey.getItems();
    Iterable<Question> _filter = Iterables.<Question>filter(_items, Question.class);
    for (final Question question : _filter) {
      if ((question instanceof survey.Number)) {
        survey.Number number = ((survey.Number) question);
        final String minLessThanUpperString = "Number max value must be larger than min value";
        final Integer min = number.getMin();
        final Integer max = number.getMax();
        boolean _and = false;
        boolean _and_1 = false;
        boolean _notEquals = (!Objects.equal(min, null));
        if (!_notEquals) {
          _and_1 = false;
        } else {
          boolean _notEquals_1 = (!Objects.equal(max, null));
          _and_1 = (_notEquals && _notEquals_1);
        }
        if (!_and_1) {
          _and = false;
        } else {
          boolean _greaterEqualsThan = (min.compareTo(max) >= 0);
          _and = (_and_1 && _greaterEqualsThan);
        }
        if (_and) {
          this.error(minLessThanUpperString, number, 
            Literals.NUMBER__MIN, 
            DslValidator.INVALID_VALUE);
          this.error(minLessThanUpperString, number, 
            Literals.NUMBER__MAX, 
            DslValidator.INVALID_VALUE);
        }
      }
    }
  }
  
  /**
   * Check that the max value in a multiple question is larger than the min value
   */
  @Check
  public void checkThatLowerIsLargerThanUpperMultiple(final Survey survey) {
    EList<Item> _items = survey.getItems();
    Iterable<Question> _filter = Iterables.<Question>filter(_items, Question.class);
    for (final Question question : _filter) {
      if ((question instanceof Multiple)) {
        Multiple multiple = ((Multiple) question);
        int _min = multiple.getMin();
        int _max = multiple.getMax();
        boolean _greaterThan = (_min > _max);
        if (_greaterThan) {
          this.error(
            "Multiple max value must be larger than min value", multiple, 
            Literals.MULTIPLE__MAX, 
            DslValidator.INVALID_VALUE);
        }
      }
    }
  }
}
