/*
 * generated by Xtext
 */
package dk.itu.smdp.survey.generator

import java.util.ArrayList
import java.util.HashMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import survey.Answer
import survey.AnswerTemplateRef
import survey.Date
import survey.Group
import survey.HasOptions
import survey.Multiple
import survey.Number
import survey.Option
import survey.Question
import survey.Scale
import survey.Single
import survey.Survey
import survey.Table
import survey.Text
import survey.Item

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class DslGenerator implements IGenerator {
	int nextId
	HashMap<Question, String> idMap
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		var survey = resource.contents.head as Survey
		
		nextId = 0
		idMap = new HashMap<Question, String>()
		
		survey.genPhp(fsa)
		survey.genLatex(fsa)
	}
	
	def genPhp(Survey survey, IFileSystemAccess fsa) {
		var body = '''
			«FOR item : survey.items»
				«item.genHtml("", false, "")»
			«ENDFOR»
		'''
		
		var template = PhpTemplate.template(survey.title, survey.description, body)
		val filename = (if (survey.name.nullOrEmpty) "index" else survey.name) + ".php"
		fsa.generateFile(filename, template)
	}
	
	def getUniqueId(Question question) {
		nextId = nextId + 1;
		var id = 'input' + nextId;
		idMap.put(question, id);
		return id;
	}
	
	def dispatch String genHtml(Group group, String dependsOn, boolean required, String pid) {
		val refId = if (group.name.nullOrEmpty) pid else pid + "-" + group.name
		'''
		<div class="group" «group.genHtmlDependsOn»>
		    «IF !group.title.nullOrEmpty»
		    <h2>«group.title»</h2>
		    «ENDIF»
		    « IF !group.description.nullOrEmpty »
		    <p class="lead">«group.description»</p>
		    «ENDIF»
			«FOR question : group.questions»
				«question.genHtml("", group.required, refId)»
			«ENDFOR»
		</div>
		'''
	}
	
	//data-rule-required="#«item.dependsOn»:checked"
	def genHtmlDependsOn(Item item) '''
		«IF !item.dependsOn.nullOrEmpty»
		data-depends-on="«item.dependsOn»"
		«ENDIF»
	'''
	
	def genHtmlHeader(Question question, boolean required) {
		question.genHtmlHeader(required, "")
	}
	
	def genHtmlHeader(Question question, boolean required, String extraAttributes) '''
		<label class="control-label" «extraAttributes»>
	        «question.title» «question.genRequiredLabel(required)»
	        «IF !question.description.nullOrEmpty»<p class="help-block">«question.description»</p>«ENDIF»
		</label>
		«IF !(question instanceof Table)»
		«question.genHiddenInput(idMap.get(question))»
		«ENDIF»
	'''
	
	def genRefIdAttr(String id, int i) '''
		«IF !id.nullOrEmpty»
		id="«id.substring(1)»-«i»"
		«ENDIF»
	'''
	
	def genRefIdAttr(String id, Answer a) '''
		«IF !id.nullOrEmpty || !a.name.nullOrEmpty»
		id="«(if (!id.nullOrEmpty) (id.substring(1)) + "-" else "") + a.name»"
		«ENDIF»
	'''
	
	def genRefIdAttr(String id) '''
		«IF !id.nullOrEmpty»
		id="«id.substring(1)»"
		«ENDIF»
	'''
	
	def dispatch String genHtml(Text question, String dependsOn, boolean required, String pid) {
		var id = getUniqueId(question)
		var refId = if (question.name.nullOrEmpty) "" else pid + "-" + question.name
		if (refId.nullOrEmpty)
			refId = "-" + id
		
		'''
		<div class="form-group" «question.genHtmlDependsOn»>
			«question.genHtmlHeader(required, '''for="«id»"''')»
		    <div class="row">
		        <div class="col-xs-4">
					«IF !question.multiline»
					<input class="form-control" «genRefIdAttr(refId)» name="«id»[answer]" «question.genRequiredAttr(required)»>
					«ELSE»
					<textarea class="form-control" «genRefIdAttr(refId)» name="«id»[answer]" rows="3" «question.genRequiredAttr(required)»></textarea>
					«ENDIF»
		        </div>
		    </div>
		</div>
		'''
	}
	
	def dispatch String genHtml(Scale question, String dependsOn, boolean required, String pid) {
		val id = getUniqueId(question)
		// For label references
		if (question.name.nullOrEmpty)
			question.name = id
		val refId = pid + "-" + question.name
		
		'''
	    <div class="form-group" «question.genHtmlDependsOn»>
	    	«question.genHtmlHeader(required)»
	        <table class="scale">
	            <tr class="top">
	            	«IF !question.minLabel.nullOrEmpty »
	            	<td></td>
	                «ENDIF»
	                «FOR i : question.min..question.max BEFORE '<td>' SEPARATOR '</td><td>' AFTER '</td>' »
	                <label for="«refId.substring(1)»-_«i»">«i»</label>
	                «ENDFOR»
	            	«IF !question.minLabel.nullOrEmpty »
	            	<td></td>
	                «ENDIF»
	            </tr>
	            <tr class="bottom">
	            	«IF !question.minLabel.nullOrEmpty »
	            	<td><label for="«refId.substring(1)»-_«question.min»">«question.minLabel»</label></td>
	                «ENDIF»
	                «FOR i : question.min..question.max BEFORE '<td>' SEPARATOR '</td><td>' AFTER '</td>' »
	                <input type="radio" name="«id»[answer]" «genRefIdAttr(refId, i)» value="«i»" «question.genRequiredAttr(required)»/>
	                «ENDFOR»
	            	«IF !question.minLabel.nullOrEmpty »
	            	<td><label for="«refId.substring(1)»-_«question.max»">«question.maxLabel»</label></td>
	                «ENDIF»
	            </tr>
	        </table>
	    </div>
		'''
	}
	
	def genDateFormat(Date question) {
		var list = new ArrayList<String>()
		
		if (question.day) {
			list.add('dd')
		}
		if (question.month) {
			list.add('mm')
		}
		if (question.year) {
			list.add('yyyy')
		}
		
		return list.join("/")
	}
	
	def genDateMinViewMode(Date question) {
		if (question.day)
			return 0
		if (question.month)
			return 1
		if (question.year)
			return 2
	}
	
	def dispatch String genHtml(Date question, String dependsOn, boolean required, String pid) {
		val id = getUniqueId(question)
		val refId = if (question.name.nullOrEmpty) "" else pid + "-" + question.name
		
		'''
		<div class="form-group" «question.genHtmlDependsOn»>
			«question.genHtmlHeader(required, '''for="«id»"''')»
		    <div class="row">
		        <div class="col-xs-4">
				    <div class="input-group date"
				    	data-date-format="«question.genDateFormat»"
				    	data-date-min-view-mode="«question.genDateMinViewMode»"
				    	«IF !question.start.nullOrEmpty»data-date-start-date="«question.start»"«ENDIF»
				    	«IF !question.end.nullOrEmpty»data-date-end-date="«question.end»"«ENDIF»
				    	>
						<input «genRefIdAttr(refId)» name="«id»[answer]" type="text" class="form-control" «question.genRequiredAttr(required)»>
						<span class="input-group-addon">
							<i class="glyphicon glyphicon-calendar"></i>
						</span>
					</div>
				</div>
				«IF question.showLimits»
				«question.genHtmlLimitsDesc»
				«ENDIF»
		    </div>
		</div>
		'''
	}
	
	def dispatch String genHtml(Number question, String dependsOn, boolean required, String pid) {
		var id = getUniqueId(question);
		val refId = if (question.name.nullOrEmpty) "" else pid + "-" + question.name
		
		'''
		<div class="form-group" «question.genHtmlDependsOn»>
	    	«question.genHtmlHeader(required, '''for="«id»"''')»
		    <div class="row">
		        <div class="col-xs-2">
		            <input type="number" class="form-control"  «genRefIdAttr(refId)» name="«id»[answer]" «question.genRequiredAttr(required)» step="1"
		            «IF question.min != null»
		            min="«question.min»" data-rule-min="«question.min»"
		            «ENDIF»
		            «IF question.max != null»
		            max="«question.max»" data-rule-max="«question.max»"
		            «ENDIF»
		            >
		        </div>
		    </div>
            «IF question.showLimits»
            «question.genHtmlLimitsDesc»
            «ENDIF»
		</div>
		'''
	}
	
	def dispatch String genHtml(Single question, String dependsOn, boolean required, String pid) {
		var id = getUniqueId(question);
		val refId = if (question.name.nullOrEmpty) "" else pid + "-" + question.name
		
		'''
		<div class="form-group" «question.genHtmlDependsOn»>
	    	«question.genHtmlHeader(required)»
			<div>
				«FOR a : question.getAnswers BEFORE '<div class="radio"><label>'
											 SEPARATOR '</label></div><div class="radio"><label>'
											 AFTER '</label></div>' »
				<input
					type="radio"
					name="«id»[answer][]"
					«genRefIdAttr(refId, a)»
					value="«a.title»"
					«question.genRequiredAttr(required)»
				/>
				«a.title»
				«ENDFOR»
				«IF question.other || !question.otherLabel.nullOrEmpty»
				<div class="radio">
				<input type="radio" name="«id»[answer][]" value="" «question.genRequiredAttr(required)»/>
				«IF !question.otherLabel.nullOrEmpty»
				«question.otherLabel»:
				«ELSE»
				Other:
				«ENDIF»
				<input class="other-option" type="text" name="«id»[answer][]"/>
				</div>
				«ENDIF»
			</div>
		</div>
		'''
	}
		
	def dispatch String genHtml(Multiple question, String dependsOn, boolean required, String pid) {
		val id = getUniqueId(question);
		val min = question.getMin(required)
		val max = question.getMax(required)
		val refId = if (question.name.nullOrEmpty) pid else pid + "-" + question.name
		val answers = question.getAnswers
		
		'''
		<div class="form-group">
			«question.genHtmlDependsOn»
	    	«question.genHtmlHeader(required || min > 0)»
		    «FOR a : answers»
		    <div class="checkbox">
			    <label>
				    <input
				    	type="checkbox"
				    	name="«id»[answer][]"
				    	«genRefIdAttr(refId, a)»
				    	value="«a.title»"
						«question.genRequiredAttr(required || min > 0)»
						«IF min > 0» data-rule-minlength="«min»" «ENDIF»
						«IF max != null» data-rule-maxlength="«max»" «ENDIF»
					/>
			    	«a.title»
			    </label>
		    </div>
			«ENDFOR»
			«IF question.other || !question.otherLabel.nullOrEmpty»
			<div class="checkbox">
			<input type="checkbox" name="«id»[answer][]" value="" «question.genRequiredAttr(required || min > 0)»/>
			«IF !question.otherLabel.nullOrEmpty»
			«question.otherLabel»:
			«ELSE»
			Other:
			«ENDIF»
			<input class="other-option" type="text" name="«id»[answer][]"/>
			</div>
			«ENDIF»
			«IF question.showLimits»
			«question.genHtmlLimitsDesc»
			«ENDIF»
		</div>
		'''
	}
	
	def dispatch String genHtml(Table question, String dependsOn, boolean required, String pid) {
		val answers = question.getAnswers
		'''
		<div class="form-group" «question.genHtmlDependsOn»>
	    	«question.genHtmlHeader(required)»
		    <table class="table table-striped">
		    	<thead>
					<tr>
						<th></th>
						«FOR a : answers»
						<th>«a.title»</th>
						«ENDFOR»
					</tr>
				</thead>
				<tbody>
					«FOR q : question.questions»
					<tr>
					    <td><label for="«var qid = getUniqueId(question)»">«q.title» «question.genRequiredLabel(required || q.required)»</label></td>
					    «genHiddenInputWithString(q.title, qid)»
					    «FOR a : answers»
					    <td>
					    <input
					    	type="«IF question.multiple»checkbox«ELSE»radio«ENDIF»"
					    	name="«qid»[answer]"
					    	value="«a.title»"
					    	«genRefIdAttr(if (q.name.nullOrEmpty) pid else pid + "-" + q.name, a)»
					    	«question.genRequiredAttr(required || q.required)»
					    /></td>
					    «ENDFOR»
					</tr>
				    «ENDFOR»
				</tbody>
			</table>
		</div>
		'''
	}
	
	def dispatch String genHtml(Question question, String dependsOn, boolean required, String pid) '''
		MISSING: «question.title» («question.class»)
	'''
	
	
	def getMin(Multiple question, boolean required) {
		var min = if (question.min != null) question.min else 0
		if ((required || question.required) && min == 0)
			min = 1
		return min
	}
	
	def getMax(Multiple question, boolean required) {
		if (question.max != null) question.max.intValue else null
	}
	
	def genRequiredLabel(Question question, boolean requiredParent)
		'''«IF requiredParent || question.required»* «ENDIF»'''
				
	def genRequiredAttr(Question question, boolean requiredParent)
		'''«IF requiredParent || question.required» required «ENDIF»'''
	
	def genHtmlLimitsDesc(Date question) {
		val s = question.genLimitsDesc
		
		if (!s.nullOrEmpty) {
			'''<p class="help-block">«s»</p>'''
		}
	}
	
	def String genLimitsDesc(Date question) {
		val start = question.start
		val end = question.end
		
		if (!start.nullOrEmpty && !end.nullOrEmpty)
			'''The date must be between «start» and «end»'''
		else if (!end.nullOrEmpty)
			'''The date must be before «end»'''
		else if (!start.nullOrEmpty)
			'''The date must be after «start»'''
	}
	
	def genHtmlLimitsDesc(Number question) {
		val s = question.genLimitsDesc
		
		if (!s.nullOrEmpty)
			'''<p class="help-block">«s»</p>'''
	}
	
	def String genLimitsDesc(Number question) {
		val min = question.min
		val max = question.max
		
		if (min != null && max != null) {
			'''The value must be between «min» and «max» (both included)'''
		}
		else if (min != null) {
			switch(min) {
				case 0:
					'''The value must be non-negative'''
				case 1:
					'''The value must be positive'''
				default:
					'''The value must be larger than or equal to «min»'''
			}
		}
		else if (max != null) {
			switch(max) {
				case -1:
					'''The value must be negative'''
				default:
					'''The value must be less than or equal to «max»'''
			}
		}
	}
	
	def String genLimitsDesc(Multiple question) {
		val min = question.min
		val max = question.max

		if (min != null && max != null) {
			if (min.intValue == max.intValue)
				'''Select «min» options'''
			else
				'''Select between «min» and «max» options'''
		}
		else if (min != null)
			'''Select at least «min» options'''
		else if (max != null)
			'''Select at most «min» options'''
	}
	
	def genHtmlLimitsDesc(Multiple question) {
		val s = question.genLimitsDesc
		
		if (!s.nullOrEmpty)
			'''<p class="help-block">«s»</p>'''
	}
	
	def getAnswers(HasOptions hasOptions) {
		var answers = new ArrayList<Answer>()
		
		for (Option option : hasOptions.options) {
			if (option instanceof Answer) {
				answers.add(option as Answer)
			}
			else if (option instanceof AnswerTemplateRef) {
				val template = (option as AnswerTemplateRef).template
				for (Answer answer : template.answers) {
					if (!answer.name.nullOrEmpty && !answer.name.contains('-')) {
						answer.name = template.name + '-' + answer.name
					}
					answers.add(answer)
				}
			}
		}
		
		return answers
	}
	
	def genHiddenInput(Question question, String id) {
		genHiddenInputWithString(question.title, id)
	}
	
	def genHiddenInputWithString(String text, String id) '''
		<input type="hidden" name="«id»[question]" value="«text»" />
	'''
	
	
	def genLatex(Survey survey, IFileSystemAccess fsa) {
		var body = '''
			«FOR item : survey.items»
				«item.genLatex("", false, "")»
				«IF item instanceof Question»
				\vspace{10mm}
				«ENDIF»
			«ENDFOR»
		'''
		
		var template = LatexTemplate.template(survey.title, survey.description, body)
		val filename = (if (survey.name.nullOrEmpty) "index" else survey.name) + ".tex"
		fsa.generateFile(filename, template)
	}
	
	def dispatch genLatex(Group group, String dependsOn, boolean required, String pid) {
		val refId = if (group.name.nullOrEmpty) pid else pid + "-" + group.name
		
		'''
		«IF !group.title.nullOrEmpty»
		\section*{\underline{«group.title»}}
	    «ENDIF»
	    «group.genLatexLabel»
	    «IF !group.description.nullOrEmpty »
	    «group.description»
	    «ENDIF»
		
		«FOR question : group.questions»
			«question.genLatex(group.dependsOn, group.required, refId)»
			\vspace{10mm}
		«ENDFOR»
		'''
	}
	
	def dispatch genLatex(Text text, String dependsOn, boolean required, String pid) {
		val count = if (text.multiline) 3 else 1
		
		'''
		«text.genLatexHeader(dependsOn, required)»
		«FOR i : 1..count»
		«genWritingLine()»
		«ENDFOR»
		'''
	}
	
	def dispatch genLatex(Scale scale, String dependsOn, boolean required, String pid) {
		'''
		«scale.genLatexHeader(dependsOn, required)»
		\noindent
		\begin{tabular}{ «IF !scale.minLabel.nullOrEmpty» r«ENDIF» «FOR i : scale.min..scale.max»c «ENDFOR»«IF !scale.maxLabel.nullOrEmpty»l «ENDIF» }
		    «FOR i : scale.min..scale.max»& «i» «ENDFOR»& \\ \hline
		    «scale.minLabel» «FOR i : scale.min..scale.max»& \Square «ENDFOR»& «scale.maxLabel»\\ \hline
		\end{tabular}
		'''
	}
	
	def dispatch genLatex(Date date, String dependsOn, boolean required, String pid) {
		'''
		«date.genLatexHeader(dependsOn, required)»
		«genWritingLine()»
		Using this format: «date.genDateFormat». \emph{«date.genLimitsDesc»}
		'''
	}
	
	def dispatch genLatex(Number number, String dependsOn, boolean required, String pid) {
		'''
		«number.genLatexHeader(dependsOn, required)»
		«genWritingLine()»
		\emph{«number.genLimitsDesc»}
		'''
	}
	
	def genWritingLine() '''
		~\newline
		\smallpencil
		\noindent \hrulefill \\
	'''
	
	def dispatch genLatex(Single question, String dependsOn, boolean required, String pid) {
		'''
		«question.genLatexHeader(dependsOn, required)»
		\emph{Please choose one only}
		\begin{description}
		«FOR a : question.getAnswers»
		\item[\Square] «a.title»
		«ENDFOR»
		«IF question.other || !question.otherLabel.nullOrEmpty»
		\item[\Square] 
		«IF !question.otherLabel.nullOrEmpty»
		«question.otherLabel»:
		«ELSE»
		Other:
		«ENDIF»
		\smallpencil \hrulefill
		«ENDIF»
		\end{description}
		'''
	}
	
	def dispatch genLatex(Multiple question, String dependsOn, boolean required, String pid) {
		'''
		«question.genLatexHeader(dependsOn, required)»
		\emph{«question.genLimitsDesc»}
		\begin{description}
		«FOR a : question.getAnswers»
		\item[\Square] «a.title»
		«ENDFOR»
		«IF question.other || !question.otherLabel.nullOrEmpty»
		\item[\Square] 
		«IF !question.otherLabel.nullOrEmpty»
		«question.otherLabel»:
		«ELSE»
		Other:
		«ENDIF»
		\smallpencil \hrulefill
		«ENDIF»
		\end{description}
		'''
	}
	
	def dispatch genLatex(Table question, String dependsOn, boolean required, String pid) {
		val answers = question.getAnswers
		'''
		«question.genLatexHeader(dependsOn, required)»
		\noindent
		\begin{tabular}{ l «FOR a : answers»c «ENDFOR» }
		«FOR a : answers»& \begin{sideways}«a.title»\end{sideways} «ENDFOR» \\ \hline
		«FOR q : question.questions»
		«q.title» «question.genLatexRequired(required || q.required)» «FOR a : answers»& \Square«ENDFOR» \\ \hline
		«ENDFOR»
		\end{tabular}
		'''
	}
	
	def genLatexHeader(Question question, String parentDependsOn, boolean required) '''
		\section{«question.title» «question.genLatexRequired(required)»}
		«question.genLatexLabel»
		«question.genLatexDependsOn(parentDependsOn)»
		«IF !question.description.nullOrEmpty»«question.description»\\«ENDIF»
	'''
	
	def genLatexRequired(Question question, boolean requiredParent)
		'''«IF requiredParent || question.required»* «ENDIF»'''
	
	def genLatexLabel(Item item)'''
		«IF !item.name.nullOrEmpty»
		\label{«item.name»}
		«ENDIF»
	'''
	
	def genLatexDependsOn(Item item, String parentDependsOn) {
		// TODO: Write nice description	
		
		'''
		«IF !parentDependsOn.nullOrEmpty»
		Please only answer this question if you replied «» to question \#\ref{«parentDependsOn»} (group).\\
		«ENDIF»
		«IF !item.dependsOn.nullOrEmpty»
		Please only answer this question if you replied «» to question \#\ref{«item.dependsOn»}.\\
		«ENDIF»
		'''
	}
}
