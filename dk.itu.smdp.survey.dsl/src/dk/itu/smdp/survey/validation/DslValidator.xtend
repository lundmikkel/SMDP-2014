/*
 * generated by Xtext
 */
package dk.itu.smdp.survey.validation

import java.util.HashMap
import org.eclipse.xtext.validation.Check
import survey.Answer
import survey.AnswerTemplate
import survey.AnswerTemplateRef
import survey.Group
import survey.HasOptions
import survey.Item
import survey.Multiple
import survey.Number
import survey.Option
import survey.Question
import survey.Scale
import survey.Single
import survey.Survey
import survey.SurveyPackage
import survey.Table
import org.eclipse.emf.common.util.EList

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class DslValidator extends AbstractDslValidator {

	public static val DUPLICATE_NAME = 'duplicateName'
	public static val INVALID_VALUE = 'invalidValue'
	public static val INVALID_DATE = 'invalidDate'
	public static val MISSING_ATTRIBUTE = 'missingAttribute'
	
	
	private static val minIsLessThanMaxString = 'Max value must be larger than min value' 

	/*
	 * Check that the min is less than max value in a scale 
	 */
	@Check
	def checkMinIsLessThanMax(Scale scale) {
		if (scale.min >= scale.max) {
			error(
				minIsLessThanMaxString,
				scale,
				SurveyPackage.Literals.SCALE__MIN,
				INVALID_VALUE
			)
			error(
				minIsLessThanMaxString,
				scale,
				SurveyPackage.Literals.SCALE__MAX,
				INVALID_VALUE
			)
		}
		
		val largeScaleString = 'Large scales may not render properly nor be very user friendly'
		if (scale.max - scale.min > 20) {
			warning(
				largeScaleString,
				scale,
				SurveyPackage.Literals.SCALE__MIN
			)
			warning(
				largeScaleString,
				scale,
				SurveyPackage.Literals.SCALE__MAX
			)
		}
		
		val bothLabelsString = 'You must specify both labels or none of them'
		if (scale.minLabel.nullOrEmpty != scale.maxLabel.nullOrEmpty) {
			if (!scale.minLabel.nullOrEmpty) {
				error(
					bothLabelsString,
					scale,
					SurveyPackage.Literals.SCALE__MIN_LABEL,
					MISSING_ATTRIBUTE
				)
			}
			else {
				error(
					bothLabelsString,
					scale,
					SurveyPackage.Literals.SCALE__MAX_LABEL,
					MISSING_ATTRIBUTE
				)
			}
		}
	}
	
	/*
	 * Check that the min is less than max value in a scale 
	 */
	@Check
	def checkMinIsLessThanMax(Number number) {
		if (number.min >= number.max) {
			error(
				minIsLessThanMaxString,
				number,
				SurveyPackage.Literals.SCALE__MIN,
				INVALID_VALUE
			)
			error(
				minIsLessThanMaxString,
				number,
				SurveyPackage.Literals.SCALE__MAX,
				INVALID_VALUE
			)
		}
	}


	/*
 * Check that the max value in a multiple question is larger than the min value 
 */
	@Check
	def checkThatLowerIsLargerThanUpperMultiple(Survey survey) {
		for (Question question : survey.items.filter(typeof(Question))) {
			if (question instanceof Multiple) {
				var multiple = question as Multiple
				if (multiple.min > multiple.max) {
					error(
						'Multiple max value must be larger than min value',
						multiple,
						SurveyPackage.Literals.MULTIPLE__MAX,
						INVALID_VALUE
					)
				}
			}
		}
	}
	
	/*
	 * Chech that questions at the same level have unique names
	 */
	@Check
	def checkUniqueQuestionNamesAtSameLevel(Survey survey) {
		// Check for questions outside groups
		(survey.items.filter(typeof(Question)) as EList<Question>).checkUniqueQuestionNamesAtSameLevel
		
		// Check for questions within groups
		for (Group group : survey.items.filter(typeof(Group))) {
			group.questions.checkUniqueQuestionNamesAtSameLevel
		}
	}
	
	def checkUniqueQuestionNamesAtSameLevel(EList<Question> questions) {
		val map = new HashMap<String, Question>()
		for (Question question : questions.filter([!name.nullOrEmpty])) {
			if (map.containsKey(question.name)) {
				error(
					'Questions at the same level cannot have the same id',
					question,
					SurveyPackage.Literals.META__NAME,
					DUPLICATE_NAME
				)
				error(
					'Questions at the same level cannot have the same id',
					map.get(question.name),
					SurveyPackage.Literals.META__NAME,
					DUPLICATE_NAME
				)
			}
			else {
				map.put(question.name, question)
			}
		}
	}


	/*
 * Check that answers in questions outside of a group have unique IDs
 */
	@Check
	def checkThatAnswerNamesAreUnique(Survey survey) {
		for (Question question : survey.items.filter(typeof(Question))) {
			var answerMap = new HashMap<String, Answer>
			if (question instanceof Single) {
				var s = question as Single
				for (Answer answer : s.options.filter(typeof(Answer))) {
					if (!answer.name.empty) {
						if (answerMap.containsKey(answer.name)) {
							error(
								'Answers within a Single must have unique IDs',
								answer,
								SurveyPackage.Literals.ANSWER__NAME,
								DUPLICATE_NAME
							)
						} else {
							answerMap.put(answer.name, answer)
						}
					}
				}
			} else if (question instanceof Multiple) {
				var m = question as Multiple
				for (Answer answer : m.options.filter(typeof(Answer))) {
					if (!answer.name.empty) {
						if (answerMap.containsKey(answer.name)) {
							error(
								'Answers within a Multiple must have unique IDs',
								answer,
								SurveyPackage.Literals.ANSWER__NAME,
								DUPLICATE_NAME
							)
						} else {
							answerMap.put(answer.name, answer)
						}
					}
				}
			}
			if (question instanceof Table) {
				var t = question as Table
				for (Answer answer : t.options.filter(typeof(Answer))) {
					if (!answer.name.empty) {
						if (answerMap.containsKey(answer.name)) {
							error(
								'Answers within a Table must have unique IDs',
								answer,
								SurveyPackage.Literals.ANSWER__NAME,
								DUPLICATE_NAME
							)
						} else {
							answerMap.put(answer.name, answer)
						}
					}
				}
			}
		}
	}

	/*
 * Check that the questions in each group have unique IDs
 */
	@Check
	def checkThatQuestionNamesInGroupsAreUnique(Survey survey) {
		var questionMap = new HashMap<String, Question>

		for (Group group : survey.items.filter(typeof(Group))) {
			for (Question question : group.questions) {

				if (!question.name.empty) {
					if (questionMap.containsKey(question.name)) {
						error(
							'Questions within a group must have unique IDs',
							question,
							SurveyPackage.Literals.META__NAME,
							DUPLICATE_NAME
						)
					} else {
						questionMap.put(question.name, question)
					}
				}
			}
		}
	}

	/*
 * Check that the answers in each question (of type Single, Multiple or Table) in each group have unique IDs
 */
	@Check
	def checkThatAnswerNamesInGroupsAreUnique(Survey survey) {
		for (Group group : survey.items.filter(typeof(Group))) {
			for (Question question : group.questions) {
				var answerMap = new HashMap<String, Answer>
				if (question instanceof Single) {
					var s = question as Single
					for (Answer answer : s.options.filter(typeof(Answer))) {
						if (!answer.name.empty) {
							if (answerMap.containsKey(answer.name)) {
								error(
									'Answers within a Single must have unique IDs',
									answer,
									SurveyPackage.Literals.ANSWER__NAME,
									DUPLICATE_NAME
								)
							} else {
								answerMap.put(answer.name, answer)
							}
						}
					}
				}
				if (question instanceof Multiple) {
					var m = question as Multiple
					for (Answer answer : m.options.filter(typeof(Answer))) {
						if (!answer.name.empty) {
							if (answerMap.containsKey(answer.name)) {
								error(
									'Answers within a Multiple must have unique IDs',
									answer,
									SurveyPackage.Literals.ANSWER__NAME,
									DUPLICATE_NAME
								)
							} else {
								answerMap.put(answer.name, answer)
							}
						}
					}
				}
				if (question instanceof Table) {
					var t = question as Table
					for (Answer answer : t.options.filter(typeof(Answer))) {
						if (!answer.name.empty) {
							if (answerMap.containsKey(answer.name)) {
								error(
									'Answers within a Table must have unique IDs',
									answer,
									SurveyPackage.Literals.ANSWER__NAME,
									DUPLICATE_NAME
								)
							} else {
								answerMap.put(answer.name, answer)
							}
						}
					}
				}
			}
		}
	}

	/*
 * Check that the AnswerTemplates have unique IDs
 */
	@Check
	def checkThatAnswerTemplateNamesAreUnique(Survey survey) {
		var answerTemplateMap = new HashMap<String, AnswerTemplate>

		for (AnswerTemplate answerTemplate : survey.templates) {
			if (!answerTemplate.name.empty) {
				if (answerTemplateMap.containsKey(answerTemplate.name)) {
					error(
						'AnswerTemplates must have unique IDs',
						answerTemplate,
						SurveyPackage.Literals.ANSWER_TEMPLATE__NAME,
						DUPLICATE_NAME
					)
				} else {
					answerTemplateMap.put(answerTemplate.name, answerTemplate)
				}
			}
		}
	}

	/*
 * Check that the ID of answers in an AnswerTemplate have unique IDs
 */
	@Check
	def checkThatNamesOfAnswersInAnswerTemplatesAreUnique(Survey survey) {
		var answerMap = new HashMap<String, Answer>

		for (AnswerTemplate answerTemplate : survey.templates) {
			for (Answer answer : answerTemplate.answers) {
				if (!answer.name.empty) {
					if (answerMap.containsKey(answer.name)) {
						error(
							'Answers within AnswerTemplates must have unique IDs',
							answer,
							SurveyPackage.Literals.ANSWER__NAME,
							DUPLICATE_NAME
						)
					} else {
						answerMap.put(answer.name, answer)
					}
				}
			}
		}
	}

	/*
 * Check that the max value in a multiple question is larger than the min value 
 */
	@Check
	def checkDependsOnReference(Survey survey) {
		var map = new HashMap<String, Question>()
		
		val ids = new HashMap<String, Item>()
		val doubleIdString = 'The ids must be unique at the same level'
		
		for (Item item : survey.items) {
			// Make sure two items at same level don't have the same id
			if (!item.name.nullOrEmpty) {
				if (ids.containsKey(item.name)) {
					error(
						doubleIdString,
						item,
						SurveyPackage.Literals.META__NAME,
						INVALID_VALUE
					)
					error(
						doubleIdString,
						ids.get(item.name),
						SurveyPackage.Literals.META__NAME,
						INVALID_VALUE
					)
				}
				else {
					ids.put(item.name, item)
				}
			}
			
			item.genRefIds("", map, null)
		}
		
		for (String key : map.keySet)
			println(key)
		
		for (Item item : survey.items) {
			if (!item.dependsOn.nullOrEmpty) {
				if (!map.containsKey(item.dependsOn)) {
					error(
						'There is no question with this id',
						item,
						SurveyPackage.Literals.ITEM__DEPENDS_ON,
						INVALID_VALUE
					)
				}
			}
		}
	}
	
	def dispatch void genRefIds(Group group, String pid, HashMap<String, Question> map, Question value) {
		val ids = new HashMap<String, Item>()
		val doubleIdString = 'The ids must be unique at the same level'
		
		for (Question question : group.questions) {	
			if (!question.name.nullOrEmpty) {
				if (ids.containsKey(question.name)) {
					error(
						doubleIdString,
						question,
						SurveyPackage.Literals.META__NAME,
						INVALID_VALUE
					)
					error(
						doubleIdString,
						ids.get(question.name),
						SurveyPackage.Literals.META__NAME,
						INVALID_VALUE
					)
				}
				else {
					ids.put(question.name, question)
				}
			}
					
			val id = if (group.name.nullOrEmpty) pid else pid + "." + group.name
			question.genRefIds(id, map, null)
		}
	}
	
	def dispatch void genRefIds(AnswerTemplateRef templateRef, String pid, HashMap<String, Question> map, Question question) {
		for (Answer answer : templateRef.template.answers) {
			val id = pid + "." + templateRef.template.name
			answer.genRefIds(id, map, question)
		}
	}
	
	def dispatch void genRefIds(Answer answer, String pid, HashMap<String, Question> map, Question question) {
		if (!answer.name.nullOrEmpty) {
			val id = (pid + "." + answer.name).substring(1)
			//println(id)
			
			if (map.containsKey(id)) {
				val ambiguousIdString = 'The id is ambiguous'
				error(
					ambiguousIdString,
					question,
					SurveyPackage.Literals.META__NAME,
					INVALID_VALUE
				)
				error(
					ambiguousIdString,
					map.get(id),
					SurveyPackage.Literals.META__NAME,
					INVALID_VALUE
				)
			}
			else {
				map.put(id, question as Question)
			}
		}
	}
	
	def dispatch void genRefIds(Question question, String pid, HashMap<String, Question> map, Question value) {
		if (question instanceof HasOptions){
			val ids = new HashMap<String, Answer>()
			val doubleIdString = 'The ids must be unique at the same level'
			
			for (Option option : (question as HasOptions).options) {
				if (option instanceof Answer) {
					var answer = option as Answer
					if (!answer.name.nullOrEmpty) {
						if (ids.containsKey(answer.name)) {
							error(
								doubleIdString,
								answer,
								SurveyPackage.Literals.ANSWER__NAME,
								INVALID_VALUE
							)
							error(
								doubleIdString,
								ids.get(answer.name),
								SurveyPackage.Literals.ANSWER__NAME,
								INVALID_VALUE
							)
						}
						else {
							ids.put(answer.name, answer)
						}
					}
				}
				else {
					val id = if (question.name.nullOrEmpty) pid else pid + "." + question.name
					option.genRefIds(id, map, question as Question)
				}
			}
		}
		else if (!question.name.nullOrEmpty) {
			val id = (pid + "." + question.name).substring(1)
			//println(id)
			
			if (map.containsKey(id)) {
				val ambiguousIdString = 'The id is ambiguous'
				error(
					ambiguousIdString,
					question,
					SurveyPackage.Literals.META__NAME,
					INVALID_VALUE
				)
				error(
					ambiguousIdString,
					map.get(id),
					SurveyPackage.Literals.META__NAME,
					INVALID_VALUE
				)
			}
			else {
				map.put(id, question)
			}
		}
	}
}
