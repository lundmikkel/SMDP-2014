/*
 * generated by Xtext
 */
package dk.itu.smdp.survey.validation

import java.util.HashMap
import survey.Survey
import org.eclipse.xtext.validation.Check
import survey.Question
import survey.SurveyPackage
import survey.Group
import survey.Answer
import survey.Multiple
import survey.Single
import survey.Table
import survey.AnswerTemplate
import survey.Scale
import survey.Number

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class DslValidator extends AbstractDslValidator {

	public static val DUPLICATE_NAME = 'duplicateName'
	public static val INVALID_VALUE = 'invalidValue'
	public static val INVALID_DATE = 'invalidDate'

	/*
 * Check that the groups have unique titles
 */
	@Check
	def checkThatGroupTitlesAreUnique(Survey survey) {
		var groupMap = new HashMap<String, Group>
		for (Group group : survey.items.filter(typeof(Group))) {
			if (!group.title.empty) {
				if (groupMap.containsKey(group.title)) {
					error(
						'Groups must have unique titles',
						group,
						SurveyPackage.Literals.META__TITLE,
						DUPLICATE_NAME
					)
				} else {
					groupMap.put(group.title, group)
				}
			}
		}
	}

	/*
 * Check that questions, not in a group, have a unique ID
 */
	@Check
	def checkThatQuestionNamesAreUnique(Survey survey) {
		var questionMap = new HashMap<String, Question>
		for (Question question : survey.items.filter(typeof(Question))) {
			if (!question.name.empty) {
				if (questionMap.containsKey(question.name)) {
					error(
						'Questions must have unique IDs',
						question,
						SurveyPackage.Literals.META__NAME,
						DUPLICATE_NAME
					)
				} else {
					questionMap.put(question.name, question)
				}
			}
		}
	}

	/*
 * Check that answers in questions outside of a group have unique IDs
 */
	@Check
	def checkThatAnswerNamesAreUnique(Survey survey) {
		for (Question question : survey.items.filter(typeof(Question))) {
			var answerMap = new HashMap<String, Answer>
			if (question instanceof Single) {
				var s = question as Single
				for (Answer answer : s.options.filter(typeof(Answer))) {
					if (!answer.name.empty) {
						if (answerMap.containsKey(answer.name)) {
							error(
								'Answers within a Single must have unique IDs',
								answer,
								SurveyPackage.Literals.ANSWER__NAME,
								DUPLICATE_NAME
							)
						} else {
							answerMap.put(answer.name, answer)
						}
					}
				}
			} else if (question instanceof Multiple) {
				var m = question as Multiple
				for (Answer answer : m.options.filter(typeof(Answer))) {
					if (!answer.name.empty) {
						if (answerMap.containsKey(answer.name)) {
							error(
								'Answers within a Multiple must have unique IDs',
								answer,
								SurveyPackage.Literals.ANSWER__NAME,
								DUPLICATE_NAME
							)
						} else {
							answerMap.put(answer.name, answer)
						}
					}
				}
			}
			if (question instanceof Table) {
				var t = question as Table
				for (Answer answer : t.options.filter(typeof(Answer))) {
					if (!answer.name.empty) {
						if (answerMap.containsKey(answer.name)) {
							error(
								'Answers within a Table must have unique IDs',
								answer,
								SurveyPackage.Literals.ANSWER__NAME,
								DUPLICATE_NAME
							)
						} else {
							answerMap.put(answer.name, answer)
						}
					}
				}
			}
		}
	}

	/*
 * Check that the questions in each group have unique IDs
 */
	@Check
	def checkThatQuestionNamesInGroupsAreUnique(Survey survey) {
		var questionMap = new HashMap<String, Question>

		for (Group group : survey.items.filter(typeof(Group))) {
			for (Question question : group.questions) {

				if (!question.name.empty) {
					if (questionMap.containsKey(question.name)) {
						error(
							'Questions within a group must have unique IDs',
							question,
							SurveyPackage.Literals.META__NAME,
							DUPLICATE_NAME
						)
					} else {
						questionMap.put(question.name, question)
					}
				}
			}
		}
	}

	/*
 * Check that the answers in each question (of type Single, Multiple or Table) in each group have unique IDs
 */
	@Check
	def checkThatAnswerNamesInGroupsAreUnique(Survey survey) {
		for (Group group : survey.items.filter(typeof(Group))) {
			for (Question question : group.questions) {
				var answerMap = new HashMap<String, Answer>
				if (question instanceof Single) {
					var s = question as Single
					for (Answer answer : s.options.filter(typeof(Answer))) {
						if (!answer.name.empty) {
							if (answerMap.containsKey(answer.name)) {
								error(
									'Answers within a Single must have unique IDs',
									answer,
									SurveyPackage.Literals.ANSWER__NAME,
									DUPLICATE_NAME
								)
							} else {
								answerMap.put(answer.name, answer)
							}
						}
					}
				}
				if (question instanceof Multiple) {
					var m = question as Multiple
					for (Answer answer : m.options.filter(typeof(Answer))) {
						if (!answer.name.empty) {
							if (answerMap.containsKey(answer.name)) {
								error(
									'Answers within a Multiple must have unique IDs',
									answer,
									SurveyPackage.Literals.ANSWER__NAME,
									DUPLICATE_NAME
								)
							} else {
								answerMap.put(answer.name, answer)
							}
						}
					}
				}
				if (question instanceof Table) {
					var t = question as Table
					for (Answer answer : t.options.filter(typeof(Answer))) {
						if (!answer.name.empty) {
							if (answerMap.containsKey(answer.name)) {
								error(
									'Answers within a Table must have unique IDs',
									answer,
									SurveyPackage.Literals.ANSWER__NAME,
									DUPLICATE_NAME
								)
							} else {
								answerMap.put(answer.name, answer)
							}
						}
					}
				}
			}
		}
	}

	/*
 * Check that the AnswerTemplates have unique IDs
 */
	@Check
	def checkThatAnswerTemplateNamesAreUnique(Survey survey) {
		var answerTemplateMap = new HashMap<String, AnswerTemplate>

		for (AnswerTemplate answerTemplate : survey.templates) {
			if (!answerTemplate.name.empty) {
				if (answerTemplateMap.containsKey(answerTemplate.name)) {
					error(
						'AnswerTemplates must have unique IDs',
						answerTemplate,
						SurveyPackage.Literals.ANSWER_TEMPLATE__NAME,
						DUPLICATE_NAME
					)
				} else {
					answerTemplateMap.put(answerTemplate.name, answerTemplate)
				}
			}
		}
	}

	/*
 * Check that the ID of answers in an AnswerTemplate have unique IDs
 */
	@Check
	def checkThatNamesOfAnswersInAnswerTemplatesAreUnique(Survey survey) {
		var answerMap = new HashMap<String, Answer>

		for (AnswerTemplate answerTemplate : survey.templates) {
			for (Answer answer : answerTemplate.answers) {
				if (!answer.name.empty) {
					if (answerMap.containsKey(answer.name)) {
						error(
							'Answers within AnswerTemplates must have unique IDs',
							answer,
							SurveyPackage.Literals.ANSWER__NAME,
							DUPLICATE_NAME
						)
					} else {
						answerMap.put(answer.name, answer)
					}
				}
			}
		}
	}

	/*
 * Check that the max value in a scale question is larger than the min value 
 */
	@Check
	def checkThatLowerIsLargerThanUpperScale(Survey survey) {
		for (Question question : survey.items.filter(typeof(Question))) {
			if (question instanceof Scale) {
				var scale = question as Scale
				if (scale.min >= scale.max) {
					val minLessThanUpperString = 'Scale max value must be larger than min value' 
					error(
						minLessThanUpperString,
						scale,
						SurveyPackage.Literals.SCALE__MIN,
						INVALID_VALUE
					)
					error(
						minLessThanUpperString,
						scale,
						SurveyPackage.Literals.SCALE__MAX,
						INVALID_VALUE
					)
				}
				
				val largeScaleString = 'Large scales may not render properly nor be very user friendly'
				if (scale.max - scale.min > 20) {
					warning(
						largeScaleString,
						scale,
						SurveyPackage.Literals.SCALE__MIN
					)
					warning(
						largeScaleString,
						scale,
						SurveyPackage.Literals.SCALE__MAX
					)
				}
				
				val bothLabelsString = 'You must specify both labels or none of them'
				if (scale.minLabel.nullOrEmpty != scale.maxLabel.nullOrEmpty) {
					println("Lower \"" + scale.minLabel + "\"")
					println("Upper \"" + scale.maxLabel + "\"")
					if (!scale.minLabel.nullOrEmpty) {
						error(
							bothLabelsString,
							scale,
							SurveyPackage.Literals.SCALE__MIN_LABEL,
							INVALID_VALUE
						)
					}
					else {
						error(
							bothLabelsString,
							scale,
							SurveyPackage.Literals.SCALE__MAX_LABEL,
							INVALID_VALUE
						)
					}
				}
			}
		}
	}

	/*
 * Check that the max value in a number question is larger than the min value 
 */
	@Check
	def checkThatLowerIsLargerThanUpperNumber(Survey survey) {
		for (Question question : survey.items.filter(typeof(Question))) {
			if (question instanceof Number) {
 				var number = question as Number
				val minLessThanUpperString = 'Number max value must be larger than min value'
				val min = number.min
				val max = number.max
				if (min != null && max != null && min >= max) {
					error(
						minLessThanUpperString,
						number,
						SurveyPackage.Literals.NUMBER__MIN,
						INVALID_VALUE
					)
					error(
						minLessThanUpperString,
						number,
						SurveyPackage.Literals.NUMBER__MAX,
						INVALID_VALUE
					)
				}
			}
		}
	}

	/*
 * Check that the max value in a multiple question is larger than the min value 
 */
	@Check
	def checkThatLowerIsLargerThanUpperMultiple(Survey survey) {
		for (Question question : survey.items.filter(typeof(Question))) {
			if (question instanceof Multiple) {
				var multiple = question as Multiple
				if (multiple.min > multiple.max) {
					error(
						'Multiple max value must be larger than min value',
						multiple,
						SurveyPackage.Literals.MULTIPLE__MAX,
						INVALID_VALUE
					)
				}
			}
		}
	}
}
